---
layout: post
title: LeetCode 热题 HOT 100
description: LeetCode 热题 HOT 100 - till 2021.04.14
category: 技术
---

## introduction 
LeetCode 热题 HOT 100 - till 2021.04.14  
标星* 小节 代表相关算法板块未涉及的 分类。

## 1 Two Pointers 双指针

使用**双指针**的思路，指针k（慢指针）用于替换元素，指针i（快指针）用于遍历序列。定义两个指针 slow 和 fast 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 nums[fast] 表示待检查的第一个元素，nums[slow−1] 或 nums[slow] 为上一个应该被保留的元素所移动到的指定位置。

### 283. [Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/) 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。  
示例：  
输入：[0,1,0,3,12]  
输出：[1,3,12,0,0]

题解：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int k = 0; // nums数组中[0, ..., k)的元素均为非0元素
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                if (i == k) { // 用于优化数组前几个元素都为非0的情况
                    k++;
                } else {
                    nums[k++] = nums[i];
                    nums[i] = 0;
                }
            }
        }
    }
}
```

tips：

- i是否等于k的判断要写在判断当前元素是否不为0之后，否则每次进入循环体i总等于k；
- 对于i不等于k的情况，就不需要交换i和k索引处元素，直接将k处元素赋值i处元素的值并将i处元素置0即可；
- 时间复杂度：O(n)	n - 序列长度；
- 空间复杂度：O(1)	没有创建新的序列，只需要常数空间存放若干变量。

### 11. [Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water/) 盛最多水的容器

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。  
示例：  
输入：[1,8,6,2,5,4,8,3,7]  
![](/images/2021-04-14-leetcode-hot-100/11.jpg)  
输出：49  
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

思路：  
设每一状态下水槽面积为 S(i,j),(0 <= i < j < n)，由于水槽的实际高度由两板中的短板决定，则可得面积公式 S(i, j) = min(h[i], h[j]) × (j - i)。在每一个状态下，无论长板或短板收窄 1 格，都会导致水槽底边宽度 -1：若向内移动短板，水槽的短板 min(h[i], h[j]) 可能变大，因此水槽面积 S(i, j) 可能增大；若向内移动长板，水槽的短板 min(h[i], h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。

题解：

```java
class Solution {
    public int maxArea(int[] height) {
        int ans = 0;
        for (int i = 0, j = height.length - 1; i < j;) {
            ans = Math.max(Math.min(height[i], height[j]) * (j - i), ans);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return ans;
    }
}
```

tips：

- 此题与[167题](https://yujie2020.github.io/2021-04-06-array-and-string-algorithm.html)思路相同；
- 时间复杂度：O(n)	n - 序列长度；
- 空间复杂度：O(1)	没有创建新的序列，只需要常数空间存放若干变量。

### 240. [Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/) 搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。  
示例：  
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5  
![](/images/2021-04-14-leetcode-hot-100/240.jpg)  
输出：true

题解：

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        for (int i = 0, j = n - 1; i < m && j >= 0;) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
```

tips：

- 此题与[167题](https://yujie2020.github.io/2021-04-06-array-and-string-algorithm.html)思路相同；
- 时间复杂度：O(m + n)；
- 空间复杂度：O(1)

### 15. [3Sum](https://leetcode-cn.com/problems/3sum/) 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。答案中不可以包含重复的三元组。  
示例：  
输入：nums = [-1,0,1,2,-1,-4]  
输出：[[-1,-1,2],[-1,0,1]]

题解：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        int len = nums.length;
        if (len < 3) return result;
        Arrays.sort(nums);
        for (int i = 0; i < len - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;
            if (nums[i] + nums[len -1] + nums[len - 2] < 0) continue;
            int left = i + 1;
            int right = len - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    List<Integer> ele = new ArrayList<>();
                    ele.add(nums[i]);
                    ele.add(nums[left]);
                    ele.add(nums[right]);
                    result.add(ele);
                    while (left < right && nums[left + 1] == nums[left]) left++;
                    left++;
                    while (left < right && nums[right - 1] == nums[right]) right--;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
}
```

tips：

- 此题与[18题](https://yujie2020.github.io/2021-04-06-array-and-string-algorithm.html)思路相同；
- 时间复杂度：快速排序O(nlogn) + 两重循环O(n^2) = O(n^2)；
- 空间复杂度：忽略存储答案的空间，O(nlogn)

### 42. [Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/) 接雨水

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  
示例：  
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]  
![](/images/2021-04-14-leetcode-hot-100/42-title.png)  
输出：6  
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

思路：  
对于下标 i，雨水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。暴力算法是对数组 height 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量，其时间复杂度为O(n^2)。动态规划算法是如果已经知道每个位置两边的最大高度，创建两个长度为 n 的数组 leftMax 和 rightMax。对于 0≤i<n，leftMax[i] 表示下标 i 及其左边的位置中height 的最大高度，rightMax[i] 表示下标 i 及其右边的位置中height 的最大高度，当 1≤i≤n−1 时，leftMax[i]=max(leftMax[i−1],height[i])，同理当 0≤i≤n−2 时，rightMax[i]=max(rightMax[i+1],height[i])，则可以在 O(n) 的时间内得到能接的雨水总量。  
双指针的思路：  
可以将空间复杂度降到 O(1)。下标 i 处能接的雨水量由leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。指针移动的过程中维护两个变量 maxL 和 maxR 的值。  
![](/images/2021-04-14-leetcode-hot-100/42-answer.png)

题解：

```java
class Solution {
    public int trap(int[] height) {
        int len = height.length;
        int result = 0;
        if (len == 0) return result;
        int left = 0, right = len - 1;
        int maxL = height[left], maxR = height[right];
        while (left < right) {
            if (maxL < maxR) { // “只取当前有效的leftMax[i]或rightMax[i]的一边更新result”，即较小的最大柱子高度，另一边虽然可能有比当前maxSide更高的柱子，但是当前maxSide已经大于有效边的maxSide，继续遍历下去只会比当前maxSide更大，maxSide同样还是会大于有效边的maxSide，故有效边的left/right更新一定是正确的
                result += maxL - height[left];
                maxL = Math.max(maxL, height[++left]);
            } else {
                result += maxR - height[right];
                maxR = Math.max(maxR, height[--right]);
            }
        } // 退出循环后总有一个单位长度未计算，但是此单位长度一定为数组中的最大值
        return result;
    }
}
```

tips：

- 时间复杂度：O(n)；
- 空间复杂度：O(1)

## 2 Sliding Window 滑动窗口

使用双指针，**滑动窗口**的思路，定义两个指针left和right分别表示子数组（滑动窗口）的开始位置和结束位置，实现不同的功能。

### 3. [Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。  
示例：  
输入：s = "pwwkew"  
输出：3  
解释：因为无重复字符的最长子串是 "wke"，所以其长度为 3。

思路：  
定义两个指针left和right分别表示子数组（滑动窗口）的开始位置和结束位置。判断子串是否含有重复字符还需要使用额外的数据结构比如数组存储ASCII为数组索引值的字符在子串（滑动窗口）中出现的频率。此题是不满足要求移动左指针寻找新的满足要求的子数组。  
![](/images/2021-04-14-leetcode-hot-100/3.png)

题解：

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] charFreq = new int[128]; // 存储ASCII为数组索引值的字符在子串（滑动窗口）中出现的频率
        int left = 0, right = -1; // nums[left, right]为滑动窗口
        int maxLen = 0;
        while (left < s.length()) {
            if (right + 1 < s.length() && charFreq[s.charAt(right + 1)] == 0) {
                charFreq[s.charAt(++right)]++;
            } else {
                charFreq[s.charAt(left++)]--;
            }
            maxLen = Math.max(maxLen, right - left + 1); // 当前子串（滑动窗口）一定不含有重复字符
        }
        return maxLen;
    }
}
```

tips：

- 对于数组来说需要注意是否越界问题，同理对于字符串来说，使用charAt()方法取值也需要注意是否越界的问题；
- char类型在运算的时候会被首先提升为int类型然后再计算，适用于算术运算、比较运算、赋值运算和数组的索引赋值，此题运用了数组的索引赋值；
- 判断时只需要使用子串起始索引left就可以，不需要再附加终止索引right的判断；
- 当字符串中出现较长的相同连续字符时left与right会交替的向前移动（滑动窗口）；
- 时间复杂度：O(n)；
- 空间复杂度：O(∣Σ∣)，此题字符集为所有 ASCII 码在 [0,128) 内的字符，即∣Σ∣=128。

### 438. [Find All Anagrams in a String](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/) 找到字符串中所有字母异位词

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母。字母异位词指字母相同，但排列不同的字符串。不考虑答案输出的顺序。  
示例：  
输入：s: "cbaebabacd" p: "abc"  
输出：[0, 6]  
解释：起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。

思路：  
窗口长度固定，每次向右移动一位，判断当前滑动窗口是否符合题意。

题解：

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int len = p.length();
        List<Integer> list = new ArrayList<>();
        if (len > s.length()) return list;
        int[] pFreq = new int[26];
        int[] sFreq = new int[26];
        int left = 0, right = len - 1;
        boolean flag = true;
        for (int i = 0; i < len; i++) {
            pFreq[p.charAt(i) - 'a']++;
            sFreq[s.charAt(i) - 'a']++;
        }
        while (right < s.length()) {
            for (int i = 0; i < 26; i++) {
                if (pFreq[i] != sFreq[i]) {
                    flag = false;
                    break;
                }
            }
            if (flag) list.add(left);
            sFreq[s.charAt(left++) - 'a']--;
            if (right + 1 < s.length()) {
                sFreq[s.charAt(++right) - 'a']++;
            } else {
                right++;
            }
            flag = true;
        }
        return list;
    }
}
```

tips：

- 此题中判断s字符串滑动窗口中字母与p字符串中字母出现的频率是否相等，即sFreq数组与pFreq元素是否相等，还可以使用java.util.Arrays类中的static boolean equals(int[] a, int[] a2)方法，如果两个指定的 int 型数组彼此相等，则返回 true；
- 时间复杂度：O(n)；
- 空间复杂度：O(∣Σ∣)，除去返回答案所用集合的空间。此题字符集（所有小写字母 ）为所有 ASCII 码在 [97, 122] 内的字符，即∣Σ∣=26*2=52。

### 76. [Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring/) 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。  
示例：  
输入：s = "ADOBECODEBANC", t = "ABC"  
输出："BANC"

思路：  
不断增加right使滑动窗口增大，直到窗口包含了字符串t的所有元素，不断增加left使滑动窗口缩小，直到碰到一个必须包含的元素，这个时候不能再left++了，记录此时滑动窗口对应的字符串和上次保存的字符串取长度更小的进行保存，故初始定义结果字符串时其长度需要大于s字符串。使left再增加一个位置，此时滑动窗口肯定不满足条件了，那么继续使得right++寻找新的满足条件的滑动窗口。此题是满足要求移动左指针寻找新的不满足要求的子数组（与其他滑动窗口题目不同，左指针移动后右指针也移动）。

题解：

```java
class Solution {
    public String minWindow(String s, String t) {
        if (t.length() > s.length()) return "";
        int left = 0, right = t.length() - 1;
        int len = t.length();
        int[] tFreq = new int[58];
        int[] sFreq = new int[58];
        boolean flag = true;
        String result = s + "a";
        for (int i = 0; i < len; i++) {
            tFreq[t.charAt(i) - 'A']++;
            sFreq[s.charAt(i) - 'A']++;
        }
        while (right < s.length()) {
            for (int i = 0; i < 58; i++) {
                if (tFreq[i] != 0 && tFreq[i] > sFreq[i]) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                while (sFreq[s.charAt(left) - 'A'] > tFreq[s.charAt(left) - 'A']) sFreq[s.charAt(left++) - 'A']--;
                result = result.length() > right - left + 1 ? s.substring(left, right + 1) : result;
                sFreq[s.charAt(left++) - 'A']--;
            }
            flag = true;
            if (right + 1 < s.length()) {
                sFreq[s.charAt(++right) - 'A']++;
            } else {
                right++;
            }
        }
        return result.length() > s.length() ? "" : result;
    }
}
```

tips：

- 此题思路与438题相近，不同的是438题中需要两个频数数组相等，此题中sFreq >= tFreq时滑动窗口满足要求，否则sFreq < tFreq时不满足要求；
- 记录频次时减去'A'，char类型在运算的时候会被首先提升为int类型然后再计算，不需要查A对应的ASCII值；
- 判断时只需要使用子串终止索引right即可；
- 时间复杂度：O(n)；
- 空间复杂度：O(∣Σ∣)，除去返回答案所用集合的空间。此题字符集（所有大小写字母 ）为所有 ASCII 码在 [65, 122] 内的字符（不包括大小写字母之间的91～96 ASCII值的字符），即∣Σ∣=58*2=116。

### 239. [Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/) 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。  
示例：  
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3  
输出：[3,3,5,5,6,7]  
解释：  
滑动窗口的位置ㅤㅤㅤㅤㅤ最大值  
[1  3  -1] -3  5  3  6  7ㅤㅤㅤㅤ3  
 1 [3  -1  -3] 5  3  6  7ㅤㅤㅤㅤ3  
 1  3 [-1  -3  5] 3  6  7ㅤㅤㅤㅤ5  
 1  3  -1 [-3  5  3] 6  7ㅤㅤㅤㅤ5  
 1  3  -1  -3 [5  3  6] 7ㅤㅤㅤㅤ6  
 1  3  -1  -3  5 [3  6  7]ㅤㅤㅤㅤ7

思路：  
有序双端队列的思路。遍历数组，使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的。当滑动窗口向右移动时，需要把一个新的元素放入队列中。如果当前遍历的数（窗口移动时的新增元素）比队尾的值大，则需要不断弹出队尾值，直到队列重新满足从大到小的要求，再添加当前遍历的数（因为**之前**比当前遍历的数小的元素的值之后滑动窗口选取元素最大值的时候一定用不上）。刚开始遍历时，有一个形成窗口的过程，当窗口大小形成（遍历到第一个窗口的最后一个索引）后，每次移动时，判断队首的值的数组下标是否在滑动窗口中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。（双端队列中索引对应数组中的元素从另一个角度来看也是滑动窗口）  
![](/images/2021-04-14-leetcode-hot-100/239.png)

题解：

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] result = new int[nums.length - k + 1];
        Deque<Integer> deque = new LinkedList<Integer>(); // 双端队列
        for (int i = 0; i < nums.length; i++) {
            while (deque.size() > 0 && nums[i] > nums[deque.getLast()]) deque.removeLast();
            deque.addLast(i); // 如果当前遍历的数比队尾的值大，则需要不断弹出队尾值，直到队列重新满足从大到小的要求，再添加当前遍历的数
            if (i - k + 1 >= 0) result[i - k + 1] = nums[deque.getFirst()]; // 当前窗口的最大值即为队首的数
            if (i - k + 1 >= deque.getFirst()) deque.removeFirst(); // 判断队首的值的数组下标是否在滑动窗口中，如果不在则需要弹出队首的值
        }
        return result;
    }
}
```

tips：

- 对java.util.Queue< E > 接口类的熟悉；
- 时间复杂度：O(n)；
- 空间复杂度：O(k)，新增最大长度为k的双端队列。

Ⅲ

## 3 Hash Table 哈希表

使用底层实现为**哈希表**的Set及Map集合等的数组相关题目。哈希表（散列表）是根据关键码值（Key value）直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表插入、查找及删除的时间复杂度均为O(1)。

### 347. [Top K Frequent Elements](https://leetcode-cn.com/problems/top-k-frequent-elements/) 前 K 个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按任意顺序返回答案。  
示例：  
输入：nums = [1,1,1,2,2,3], k = 2  
输出：[1,2]

题解：

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap<>();
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);
        }
        List<Integer>[] bucket = new List[len + 1];
        for (int key : freq.keySet()) {
            int value = freq.get(key);
            if (bucket[value] == null) bucket[value] = new ArrayList();
            bucket[value].add(key);
        }
        int count = 0; // 计数当前为出现频率第k高的元素
        int[] result = new int[k];
        for (int i = len; count < k; i--) {
            if (bucket[i] != null) {
                for (int ele : bucket[i]) {
                    if (count < k) {
                        result[count++] = ele;
                    } else {
                        break;
                    }
                }
            }
        }
        return result;
    }
}
```

tips：

- 与[451题](https://yujie2020.github.io/2021-04-06-array-and-string-algorithm.html)思路相同；
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 49. [Group Anagrams](https://leetcode-cn.com/problems/group-anagrams/) 字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。所有输入均为小写字母。不考虑答案输出的顺序。  
示例：  
输入：["eat", "tea", "tan", "ate", "nat", "bat"]  
输出：

```
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

思路：  
互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，将每个字母出现的次数使用字符串表示，作为哈希表的键。键的类型为String，内容为从a到z的出现字母拼接此字母的出现次数。

题解：

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> resMap = new HashMap<>();
        for (String str : strs) {
            int[] freq = new int[26];
            for (int i = 0; i < str.length(); i++) {
                freq[str.charAt(i) - 'a']++;
            }
            StringBuffer keySb = new StringBuffer();
            for (int i = 0; i < 26; i++) {
                if (freq[i] != 0) {
                    keySb.append((char) (i + 'a')).append(freq[i]);
                }
            }
            String keyStr = keySb.toString();
            List<String> value = resMap.getOrDefault(keyStr, new ArrayList<String>());
            value.add(str);
            resMap.put(keyStr, value);
        }
        return new ArrayList<List<String>>(resMap.values());
    }
}
```

tips：

- 使用java.lang.StringBuffer类，线程安全的可变字符序列，一个类似于 String 的字符串缓冲区。StringBuffer append(char c) 方法将 char 参数的字符串表示形式追加到此序列，并返回当前对象自身。使用链式编程（如果方法的返回值是一个对象，可以根据对象继续调用方法）；
- 通过键获取值时，使用 java.util.Map<K,V>接口类中的default V getOrDefault (Object key, V defaultValue) 方法（JDK1.8 新特性）返回指定键映射到的值，如果此映射不包含该键的映射，则返回 defaultValue。来在第一次获取值时新建值ArrayList<String>对象；
- 返回值使用ArrayList(Collection<? extends E> c) 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。来构造新的结果集合，且参数使用Map<K,V>类中的Collection<V> values() 方法（新特性）返回此map集合中包含的值的Collection视图；
- 时间复杂度：OO(n*(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26；
- 空间复杂度：O(n*(k+∣Σ∣))，需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(∣Σ∣)，在渐进意义下小于 前者，可以忽略不计。

## 4 Hash Table (LUT) 哈希表（查找表）

使用底层实现为**哈希表**的Set及Map集合等的数组相关题目。查找表（Look-Up Table）是由同一类型的数据元素（或记录）构成的集合。查找操作为根据给定的某个K值，在查找表中寻找一个其键值等于K的数据元素，利用查找表的key及value来解决问题。

### 1. [Two Sum](https://leetcode-cn.com/problems/two-sum/) 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。  
示例：  
输入：nums = [3,2,4], target = 6  
输出：[1,2]

思路：  
使用Map集合存储数组的值及其索引，对于数组每一个元素 i，首先查询哈希表中是否存在 target - i 再将 i 插入到哈希表中，即能保证同一个元素在答案里不重复出现。

题解：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numsMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (numsMap.containsKey(complement)) return new int[] {numsMap.get(complement), i};
            numsMap.put(nums[i], i);
        }
        return null;
    }
}
```

tips：

- 时间复杂度：O(n)，哈希表插入、查找及删除的时间复杂度均为O(1)；
- 空间复杂度：O(n)

## 5 Quick Sort - Partition (Divide and Conquer) 快速排序 - 三路快排（分治算法）

使用**快速排序**、**三路快排**的思路。

### 75. [Sort Colors](https://leetcode-cn.com/problems/sort-colors/) 颜色分类

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。  
示例：  
输入：nums = [2,0,1]  
输出：[0,1,2]

思路：  
![](/images/2021-04-14-leetcode-hot-100/75.png)

题解：

```java
class Solution {
    public void sortColors(int[] nums) {
        int zero = -1; // [0, ..., zero]的元素都为0
        int two = nums.length; // [two, ..., nums.length - 1]的元素都为2
        for (int i = 0; i < two; ) { // 索引i用于遍历
            if (nums[i] == 0) {
                nums[i++] = nums[++zero];
                nums[zero] = 0;
            } else if (nums[i] == 2) { // 这里i不能递增，因为和--two处元素交换，--two处的元素为一不确定的值（未检查的值）
                nums[i] = nums[--two];
                nums[two] = 2;
            } else { // nums[i] == 1
                i++;
            }
        }
    }
}
```

tips：

- 时间复杂度：O(n)	n - 序列长度；
- 空间复杂度：O(1)，没有创建新的序列，只需要常数空间存放若干变量。

### 215. [Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。  
示例：  
输入：[3,2,3,1,2,4,5,5,6] 和 k = 4  
输出：4

思路：  
用快速排序来解决这个问题，先对原数组排序，再返回倒数第 k 个位置，这样平均时间复杂度是 O(nlogn)。每次经过「划分」操作后，一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，就已经找到了答案。 只需关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，不需要关心。改进快速排序算法：在分解的过程当中，对子数组进行划分，如果划分得到的 q 正好就是需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。  
![](/images/2021-04-14-leetcode-hot-100/215.png)

题解：

```java
class Solution {

    Random random = new Random();

    public int findKthLargest(int[] nums, int k) {
        int index = nums.length - k; // 第k大元素的索引
        return randomPartition(nums, 0, nums.length - 1, index);
    }

    // 用于判别继续向左半部分还是右半部分划分（迭代），pivot中轴值在下一迭代部分中随机选取
    private int randomPartition(int[] nums, int left, int right, int index) {
        int pivotIndex = random.nextInt(right - left + 1) + left;
        swap(nums, pivotIndex, right); // 将pivot中值交换到数组末尾
        int result = partition(nums, left, right);
        if (result == index) return nums[result];
        return result > index ? randomPartition(nums, left, result - 1, index) : randomPartition(nums, result + 1, right, index);
    }

    // 划分的方法
    private int partition(int[] nums, int left, int right) {
        int pivot = nums[right]; // 中轴值（位于数组末尾）
        int i = left - 1; // [left, ..., i]的元素都小于pivot，[i + 1, ..., right]的元素都大于等于pivot
        for (int j = left; j < right; j++) {
            if (nums[j] < pivot) {
                swap(nums, ++i, j);
            }
        }
        swap(nums, i + 1, right); // 将中轴值归于正确的位置
        return i + 1; // 中轴值的索引
    }

    // 数组中索引i及索引j处的元素对调位置
    private void swap(int[] array, int i, int j) {
        int temp = array[j];
        array[j] = array[i];
        array[i] = temp;
    }
}
```

tips：

- 这里也用到了双指针的思想，指针i用于替换元素（慢指针），指针j用于遍历数组（快指针）；
- 时间复杂度：O(n)，快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题都划分成 1 和 n - 1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n^2)。这里引入随机化来加速这个过程，它的时间代价的期望是 O(n)。（证明过程：《算法导论》9.2）
- 空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为O(logn)。

## 6 Prefix Sum 前缀和

通常涉及连续子数组的问题，使用前缀和来解决。通过前缀和数组可以轻松得到每个区间（子数组）的和。前缀和数组sum保存数组num前 n 位的和，sum[i] = num[0] + num[1] + ... + num[i]，则区间（子数组）num[i, ..., j]所有元素的和为sum[j] - sum [i - 1]。

### 560. [Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k/) 和为K的子数组

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。  
示例：  
输入：nums = [1,1,1], k = 2  
输出：2 , [1,1] 与 [1,1] 为两种不同的情况。

思路：  
定义 pre[i] 为 nums[0..i] 里所有数的和，即以元素i为结尾的前缀和，使用前缀和及哈希表（查找表）的思路，建立哈希表 map，以前缀和为键，出现次数为对应的值，记录 pre[i] 出现的次数。每遍历一个元素i，考虑以 i 结尾的和为 k 的连续子数组个数，只需要统计有多少个前缀和为 pre[i]−k 的 pre[j]，即nums[j+1, ..., i]连续子数组的和为k，总的数组中和为k的连续子数组的不同种数就为以每遍历的元素i结尾情况的总和。  
![](/images/2021-04-14-leetcode-hot-100/560.png)

题解：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSumCount = new HashMap<>();
        prefixSumCount.put(0, 1); // 前缀和为0的次数为1
        int sum = 0;
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            result += prefixSumCount.getOrDefault(sum - k, 0);
            prefixSumCount.put(sum, prefixSumCount.getOrDefault(sum, 0) + 1);
        }
        return result;
    }
}
```

tips：

- 满足要求的连续子数组可以为当前元素的前缀和（即为nums[0, ..., i]），故统计前缀和出现次数的map集合需要初始化为 key 为 0 value 为 1 的键值对；
- 时间复杂度：O(n)；
- 空间复杂度：O(n)，哈希表在最坏情况下可能有 n 个不同的键值。

## 7 Binary Search 二分查找*

二分/折半查找算法，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。对于二分查找算法的题目，重点是**边界条件的判断**（首先要明确变量的含义，其次注意各位置比较运算符的正确性）。

### 4. [Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/) 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 中位数 。  
示例：  
输入：nums1 = [1,2], nums2 = [3,4]  
输出：2.50000  
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

思路：  
使用二分查找及划分数组的思路。将两个数组进行切分，由于 0 <= m1 <= len1 ，为了保证 0 <= m2 <= len2，则必须保证 len1 <= len2。  
![](/images/2021-04-14-leetcode-hot-100/4.png)

题解：

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        if (len1 > len2) return findMedianSortedArrays(nums2, nums1);
        int k = (len1 + len2 + 1) / 2; // 需要从两个数组中总共选取的元素的个数
        int left = 0, right = len1; // m1可能取的值的范围
        while (left < right) { // 因为循环内不会出现m1 = len1的情况，所以不会出现m2 = 0的情况
            int m1 = (left + right) / 2;
            int m2 = k - m1;
            if (nums1[m1] < nums2[m2 - 1]) { // 不会有越界的问题
                left = m1 + 1;
            } else {
                right = m1;
            }
        }
        int m1 = left; // 从nums1数组中选取元素的个数，最大为len1
        int m2 = k - m1; // 从nums2数组中选取元素的个数
        int c1 = Math.max(m1 == 0 ? Integer.MIN_VALUE : nums1[m1 - 1], m2 == 0 ? Integer.MIN_VALUE : nums2[m2 - 1]);
        if ((len1 + len2) % 2 == 1) return c1;
        int c2 = Math.min(m1 == len1 ? Integer.MAX_VALUE : nums1[m1], m2 == len2 ? Integer.MAX_VALUE : nums2[m2]);
        return (c1 + c2) * 0.5;
    }
}
```

tips：

- 选取最短的数组以进行二分查找采用递归的方式（最多只自己调用自己一次）；
- 对于return (c1 + c2) * 0.5，一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种，一个int类型与double类型运算时-->int类型将会自动提升为double类型进行运算；
- 时间复杂度：O(log(min(m, n)))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。查找的区间是 [0, min(m, n)]，而该区间的长度在每次循环之后都会减少为原来的一半。所以只需要执行 log(min(m, n)) 次循环；
- 空间复杂度：O(1)

### 33. [Search in Rotated Sorted Array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。  
示例：  
输入：nums = [4,5,6,7,0,1,2], target = 0  
输出：4

思路：  
题目描述的旋转后的排序数组，二分查找过程中每次将数组一分为二后，其中一定有一部分是有序的，另一个部分可能是有序也能是部分有序。对于前半部分有序的情况（即 nums[left] <= nums[mid]，这里使用小于等于是为了当循环只剩两个数的时候mid值会和left值相等，而target对应的数在right位置），当target在此前半部分中（即 nums[left] <= target && target < nums[mid]，这里还需要加上 nums[left] <= target 的判断才能保证target在此前半部分中，使用<=是为了target可能在left位置，后半部分有序同理）则在此部分中继续搜索，否则在另一可能部分有序部分搜索；对于后半部分有序的情况同理。eg：排序数组 [1 2 3 4 5 6 7] 旋转后可以大致分为 [2 3 4 5 6 7 1] 和 [6 7 1 2 3 4 5] 两类。

题解：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            if (nums[left] <= nums[mid]) { // 左边有序
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else { // 右边有序
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right  = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

tips：

- 时间复杂度：O(logn)
- 空间复杂度：O(1)

### 34. [Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。  
示例：  
输入：nums = [5,7,7,8,8,8,8,10], target = 8  
输出：[3,6]

思路：  
此题 while循环使用 left < right 的判断方式，则当退出循环时 left = right，判断 nums[left] == target即找到。搜索过程中数组的中间元素mid使用[位运算](https://yujie2020.github.io/2021-05-03-binary-digit-and-bitwise-operation.html)来求解，将位模式右移一位。求target在数组中的开始位置，mid中间数下取整，即mid = left + right >> 1，当while循环的最后一次执行中，保证left = mid（因target <= nums[mid]时right = mid，防止陷入死循环）；求target在数组中的结束位置，mid中间数上取整，即mid = left + right >> 1，当while循环的最后一次执行中，保证right = mid。（因target >= nums[mid]时left = mid，防止陷入死循环）

题解：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};
        int len = nums.length;
        if (len == 0) return result;
        int left = 0, right = len - 1;
        while (left < right) {
            int mid = left + right >> 1;
            if (target <= nums[mid]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        if (nums[left] != target) {
            return result;
        } else { // 已找出target在数组中的开始位置
            result[0] = left;
            right = len - 1; // 不再重新定义left = 0，使搜索范围缩小为target开始位置到数组末尾，提高程序执行效率
            while (left < right) {
                int mid = left + right + 1 >> 1;
                if (target >= nums[mid]) {
                    left = mid;
                } else {
                    right = mid - 1;
                }
            }
            result[1] = left; // 即使target只出现了一次，进入此循环的有效数组范围任包括target开始位置，故可找到其结束位置=开始位置
            return result;
        }
    }
}
```

tips：

- 时间复杂度：O(logn)
- 空间复杂度：O(1)

## 8 Data Structure 数据结构*

使用栈等数据结构的常规题目。

### 20. [Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/) 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。  
示例：  
输入：s = "([)]"  
输出：false

思路：  
遍历字符串中的所有字符，使用一个栈存储左括号，遍历到右括号则与栈顶弹出的左括号进行匹配，不匹配或者栈为空则返回false，退出循环后判断栈是否为空，为空则返回false，否则返回true。

题解：

```java
class Solution {
    public boolean isValid(String s) {
        int len = s.length();
        if (len % 2 == 1) return false;
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < len; i++) {
            char ch = s.charAt(i);
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (ch == ')') {
                    if (stack.empty() || stack.pop() != ch - 1) return false;
                } else {
                    if (stack.empty() || stack.pop() != ch - 2) return false;
                }
            }
        }
        if (!stack.empty()) return false;
        return true;
    }
}
```

tips：

- 当数组长度为奇数时则直接返回false；
- 查询ASCII表，‘(’ 与 ‘)’间ASCII值差为1，‘[’ 与 ‘]’ 和 ‘{’ 与 ‘}’间ASCII值差为2；
- 时间复杂度：O(n)；
- 空间复杂度：O(n)，栈中字符数量最多为n

### 32. [Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses/) 最长有效括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。  
示例：  
输入：s = ""( ) ) ( ) ( **( ( ) )**""  
输出：4

思路：  
遍历字符串中的所有字符，使用一个栈存储左括号，并且保证**栈底**永远为上一个未匹配的右括号的索引（即表示新的有效子串开始索引的上一个索引），其作用为更新有效子串长度时，当弹出 '('后栈顶元素可能为上一个未匹配的右括号的索引（即新的有效子串开始索引的上一个索引）（比如“) ( ) ( ( ) )”的例子），所以如果不保存上一个未匹配的右括号的索引，求有效子串长度时栈为空，无法获得当前有效子串开始索引的上一个索引。当遍历到右括号则弹出栈顶匹配的元素（左括号）。

题解：

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1); // 保证栈底永远为上一个未匹配的右括号的索引（即表示新的有效子串开始索引的上一个索引，故需要初始化栈底元素-1）
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') { // 当前元素为'('则将其索引添加到栈顶
                stack.push(i);
            } else {
                stack.pop(); // 弹出与')'匹配的'('的索引（弹出后栈顶为上一个未匹配的左括号的索引或者上一个未匹配的右括号的索引（即新的有效子串开始索引的上一个索引）），或者当栈中只剩一个元素时弹出需要更新的上一个未匹配的右括号的索引（弹出后栈为空）
                if (stack.empty()) {
                    stack.push(i); // 当栈中只剩一个元素时弹出后为空，更新上一个未匹配的右括号的索引
                } else {
                    result = Math.max(result, i - stack.peek()); // 当前右括号匹配的有效子串长度，即当前右括号的索引减去上一个未匹配的左括号的索引的长度（不能使用当前右括号的索引减去上一个未匹配的右括号的索引，因为这其中可能还会有未匹配的左括号）或者当栈内所有'('全部匹配完毕则减去上一个未匹配的右括号的索引（新的有效子串开始索引的上一个索引）
                }
            }
        }
        return result;
    }
}
```

tips：

- 做一道算法题之前，首先考虑代表性强的输入示例，能涵盖各种尽可能多的条件/情况（边界条件）。eg：此题的一个示例：( ) ) ( ) ( ( ( ) )；
- 时间复杂度：O(n)；
- 空间复杂度：O(n)，栈的大小在最坏情况下会达到 n + 1

### 84. [Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 柱状图中最大的矩形

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。  
示例：  
输入：[2,1,5,6,2,3]  
![](/images/2021-04-14-leetcode-hot-100/84-title.png)  
输出：10

思路：  
使用单调栈（单调递增栈：栈内元素保持单调递增 / 单调递减栈：栈内元素保持单调递减）的思路。遍历数组，当新的元素（柱子高度）比栈顶元素（柱子高度对应的数组索引）大或者相等，就入栈（存入栈中的都为数组的索引），否则如果新的元素较小就一直将栈内元素弹出，直到栈顶比新元素小。每个元素（高度）都会入栈出栈一次，在出栈操作时得到前后边界并计算面积以更新结果，最终遍历结束对每个高度都求了一次面积，结果为其中的最大值。  
每个元素（高度）计算面积时的边界为：left = 栈顶索引（一定为当前弹出高度左边的第一个比当前弹出高度底的位置，中间为之前弹出的比当前弹出高度高的元素，所以计算面积时此左边界一定正确），right = 当前元素高度的索引（一定为当前弹出高度右边的第一个比当前弹出高度底的位置，中间为之前弹出的比当前弹出高度高的元素，所以计算面积时此右边界一定正确）。因为边界位置总位于有效面积边界索引的左右两边，故高度数组需要左右各扩容一位且值（高度）为0。  
![](/images/2021-04-14-leetcode-hot-100/84-answer.png)

题解：

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int result = 0;
        int len = heights.length;
        int[] newHeights = new int[len + 2];
        for (int i = 1; i < len + 1; i++) {
            newHeights[i] = heights[i - 1];
        }
        stack.push(0);
        for (int i = 1; i < len + 2; i++) {
            while (newHeights[i] < newHeights[stack.peek()]) {
                int heightIndex = stack.pop();
                int left = stack.peek();
                int right = i;
                result = Math.max(result, (right - left - 1) * newHeights[heightIndex]);
            }
            stack.push(i);
        }
        return result;
    }
}
```

tips：

- 时间复杂度：O(N)，输入数组里的每一个元素最多入栈一次出栈一次；
- 空间复杂度：O(N)，栈的空间最大为 N

### 85. [Maximal Rectangle](https://leetcode-cn.com/problems/maximal-rectangle/) 最大矩形

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。  
示例：  
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]  
![](/images/2021-04-14-leetcode-hot-100/85-title.jpg)  
输出：6

思路：  
使用单调栈的思路。建立高度数组heights[matrix[0].length + 2]，首先遍历矩阵数组的每一行，其次遍历此行内的每一个元素，对每行内的元素matrix\[i][j]，如果其等于1则在其高度数组heights[j+1]++（表示在已经遍历过的前几行当前列累加的1的高度上再加1单位长度的高度），如果等于0则将高度数组heights[j+1]当前列的累加1的高度重新置0，在一行中的所有元素遍历完成之后建立了当前行的有效高度数组heights[]，之后建立单调栈当新的元素（1的高度）比栈顶元素（1的高度对应的数组索引）大或者相等，就入栈（存入栈中的都为数组的索引），否则如果新的元素较小就一直将栈内元素弹出，直到栈顶比新元素小。每个元素（高度）都会入栈出栈一次，在出栈操作时得到前后边界并计算面积以更新结果，最终遍历结束对每个高度都求了一次面积，结果为其中的最大值。对每一行执行上述操作即可求出结果。  
![](/images/2021-04-14-leetcode-hot-100/85-answer.png)

题解：

```java
class Solution {
    public int maximalRectangle(char[][] matrix) { // 矩阵数组的元素类型为char
        int result = 0;
        int row = matrix.length;
        if (row == 0) return result;
        int col = matrix[0].length;
        int[] heights = new int[col + 2];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++){
                if (matrix[i][j] == '1') {
                    heights[j + 1]++;
                } else {
                    heights[j + 1] = 0;
                }
            }
            Stack<Integer> stack = new Stack<>();
            stack.push(0);
            for (int j = 1; j < col + 2; j++) {
                while (heights[j] < heights[stack.peek()]) {
                    int heightIndex = stack.pop();
                    int left = stack.peek();
                    int right = j;
                    result = Math.max(result, heights[heightIndex] * (right - left - 1));
                }
                stack.push(j);
            }
        }
        return result;
    }
}
```

tips：

- 与84题思路相似；
- 对于此类题目高度数组两端分别需要添加0元素的做法也成为**哨兵**；
- 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数；
- 空间复杂度：O(n)，栈的空间最大为 n

### 221. [Maximal Square](https://leetcode-cn.com/problems/maximal-square/) 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。  
示例：  
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]  
![](/images/2021-04-14-leetcode-hot-100/221.jpg)  
输出：4

思路：  
使用单调栈的思路，当有效矩形面积的宽度大于等于当前高度时更新结果。

题解：

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int result = 0;
        int row = matrix.length;
        if (row == 0) return result;
        int col = matrix[0].length;
        int[] heights = new int[col + 2];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == '1') {
                    heights[j + 1]++;
                } else {
                    heights[j + 1] = 0;
                }
            }
            Stack<Integer> stack = new Stack<>();
            stack.push(0);
            for (int j = 1; j < col + 2; j++) {
                while (heights[j] < heights[stack.peek()]) {
                    int heightIndex = stack.pop();
                    int left = stack.peek();
                    int right = j;
                    int height = heights[heightIndex];
                    int width = right - left - 1;
                    if (width >= height) result = Math.max(result, height * height); // 宽度大于高度才能形成正方形
                }
                stack.push(j);
            }
        }
        return result;
    }
}
```

tips：

- 与85题思路相同；
- 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数；
- 空间复杂度：O(n)，栈的空间最大为 n

## 9 General - Array & Math 常规 - 数组和数学*

常规数组题目，遍历，条件判断，... 。以及数学题。

### 31. [Next Permutation](https://leetcode-cn.com/problems/next-permutation/) 下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。  
示例：  
输入：nums = [1,2,3,4,6,5]  
输出：[1,2,3,5,4,6]

思路：  
倒序遍历数组，寻找到第一对升序的相邻元素 i-1 和 i，**此时数组中从 i 到末尾都为降序**，升序的元素 i-1 即为该替换的元素，在此元素 i-1 后查找一个比它大的且尽量小的元素与其替换，因数组从 i 到末尾都为降序，故再次倒序遍历数组，查找第一个大于元素 i 的元素即为替换的元素，替换元素 i-1 和j，与此同时，**替换后数组从 i 到末尾还为降序**，替换后还需要使排列增加的幅度尽可能小，故再对数组从 i 到末尾的子数组进行升序排序。

题解：

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len <= 1) return;
        for (int i = len - 1; i > 0; i--) {
            if (nums[i] > nums[i - 1]) { // 倒序遍历查找第一对升序的相邻元素
                for (int j = len - 1; j >= i; j--) { // 倒序遍历查找第一个大于nums[i-1]的元素，并且一定能找到
                    if (nums[j] > nums[i - 1]) {
                        int temp = nums[j];
                        nums[j] = nums[i - 1];
                        nums[i - 1] = temp;
                        reverse(nums, i, len - 1);
                        return; // 整个nextPermutation方法结束，将不会执行后续的语句
                    }
                }
            }
        }
        reverse(nums, 0, len - 1); // 未找到升序的相邻元素，则整个数组为降序（不存在下一个更大的排列）
    }

    private void reverse(int[] nums, int left, int right) {
        while (left < right) {
            int temp = nums[right];
            nums[right--] = nums[left];
            nums[left++] = temp;
        }
    }
}
```

tips：

- Java中标识符（在程序中自定义的类名、方法名和变量名等）不能是关键字（Java中已经定义好的单词，具有特殊含义，例如 public, class, static, void 等），故这里reverse方法名不能使用switch；
- 需要重新排序的子数组（数组）都为降序，则可以使用反转的方法来降低时间复杂度；
- 使用return语句起到结束方法继续执行的作用（短路）;
- 时间复杂度：O(n)，降序数组的升序排列时间复杂度也为O(n)
- 空间复杂度：O(1)

### 238. [Product of Array Except Self](https://leetcode-cn.com/problems/product-of-array-except-self/) 除自身以外数组的乘积

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。请不要使用除法，且在 O(*n*) 时间复杂度内完成此题。  
示例：  
输入：[1,2,3,4]  
输出：[24,12,8,6]

思路：  
output[i] 表示的乘积 = 当前数 i 左边的乘积 * 当前数 i 右边的乘积。使用两次循环来分别求解左边的乘积和右边的乘积。

题解：

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length; // len > 1
        int[] result = new int[len];
        int l = 1, r = 1; // l为当前索引（包含）左边元素的乘积，r为当前索引（包含）右边元素的乘积
        for (int i = 0; i < len; i++) { // result[i] = nums[0,...,i-1]中元素的乘积
            result[i] = l;
            l *= nums[i];
        }
        for (int i = len - 1; i >= 0; i--) { // result[i] *= nums[i+1,...,end]中元素的乘积
            result[i] *= r; // 这里为 *=
            r *= nums[i];
        }
        return result;
    }
}
```

tips：

- 时间复杂度：O(n)；
- 空间复杂度：O(1)，输出数组不被视为额外空间

### 55. [Jump Game](https://leetcode-cn.com/problems/jump-game/) 跳跃游戏

给定一个非负整数数组 `nums` ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。  
示例：  
输入：nums = [2,3,1,1,4]  
输出：true  
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

思路：  
如果某一个作为 起跳点 的格子 i 可以跳跃的距离是 nums[i]，那么表示后面 nums[i] 个格子都可以作为 起跳点。对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。如果某次循环更新后的 能跳到最远的距离 大于数组最后一个下标，则退出循环。

题解：

```java
class Solution {
    public boolean canJump(int[] nums) {
        int maxLen = 0; // 可以到达的最大有效距离的索引
        for (int i = 0; i <= maxLen; i++) { // 条件判断语句的边界条件在每次执行循环体的过程中动态更新
            maxLen = Math.max(maxLen, i + nums[i]);
            if (maxLen >= nums.length - 1) return true;
        }
        return false;
    }
}
```

tips：

- 使用了for循环条件判断语句动态变化的思路；
- 时间复杂度：O(n)；
- 空间复杂度：O(1)

### 56. [Merge Intervals](https://leetcode-cn.com/problems/merge-intervals/) 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。  
示例：  
输入：intervals = [[1,3],[2,6],[7,10],[15,18]]  
输出：[[1,6],[7,10],[15,18]]  
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。

思路：  
先根据区间的起始位置进行快速排序（升序），再进行 n−1 次 两两合并或者添加到结果集。

题解：

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int len = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() { // 泛型为一维数组，第一参数为泛型数组（故最终为二维数组）
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        int[][] result = new int[len][2]; // 初始化为可能的最大长度
        int index = -1;
        result[++index] = intervals[0];
        for (int i = 1; i < len; i++) {
            if (intervals[i][0] > result[index][1]) { // 当前区间的起始位置大于结果数组中最后区间的终止位置则不合并，直接将当前区间加入结果数组
                result[++index] = intervals[i];
            } else { // 将当前区间合并至结果数组的最后区间
                result[index][1] = Math.max(result[index][1], intervals[i][1]);
            }
        }
        return Arrays.copyOf(result, index + 1); // 返回值需要截取有效长度
    }
}
```

tips：

- 泛型E可以是数组；
- 使用成员变量 index 记录result二维数组的有效长度；
- 使用java.util.Arrays类中的 static <T> void sort(T[] a, Comparator<? super T> c)  方法，根据指定比较器产生的顺序对指定对象数组进行排序。 对二维数组intervals进行排序；
- 快速排序的时间复杂度为O(nlogn)，空间复杂度为O(logn)；
- 时间复杂度：O(nlogn)，排序sort方法的时间复杂度，除去排序的开销只需要一次线性扫描；
- 空间复杂度：O(logn)，除存储答案所需要的空间外，排序所需要的空间复杂度为O(logn)

### 48. [Rotate Image](https://leetcode-cn.com/problems/rotate-image/) 旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。  
示例：  
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]  
![](/images/2021-04-14-leetcode-hot-100/48.jpg)  
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

思路：  
对于矩阵数组matrix中第 i 行的第 j 个元素，矩阵顺时针旋转 90 度后，它将出现在倒数第 i 列的第 j 个位置，即对于矩阵中的元素 matrix\[row][col]，在旋转后它的新位置为 matrix_new\[col][len-1−row]。使用翻转操作代替旋转操作，首先将矩阵的所有元素相对中轴横线进行上下翻转：  
matrix\[row][col] --> matrix\[len−1-row][col]  
其次将矩阵的所有元素相对斜对角线进行翻转：  
matrix\[len−1-row][col] --> matrix\[col][len−1-row]  
两次翻转后，即为满足要求的矩阵数组。

题解：

```java
class Solution {
    public void rotate(int[][] matrix) {
        int len = matrix.length;
        for (int i = 0; i < len / 2; i++) { // 将矩阵的所有元素相对中轴横线进行上下翻转
            for (int j = 0; j < len; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[len - 1 - i][j];
                matrix[len - 1 - i][j] = temp;
            }
        }
        for (int i = 0; i < len - 1; i++) { // 将矩阵的所有元素相对斜对角线进行翻转
            for (int j = i + 1; j < len; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

tips：

- 时间复杂度：O(n^2)，每一次翻转操作都需要枚举矩阵中一半的元素（n^2 / 2）；
- 空间复杂度：O(1)

### 62. [Unique Paths](https://leetcode-cn.com/problems/unique-paths/) 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。求解问总共有多少条不同的路径。  
示例：  
输入：m = 3, n = 7  
![](/images/2021-04-14-leetcode-hot-100/62.png)  
输出：28

思路：  
使用数学运用的思路。从左上角到右下角的过程中，总共需要移动 m+n−2 次，其中有 m−1 次向下移动，n−1 次向右移动。因此不同路径的总数就等于从 m+n−2 次移动中选择 m−1 次向下移动的方案数（剩下 n-1 次则填补为向右移动）(也可以理解为在 m+n−2 个空位上选择不同的 m−1 个空位填充为向下移动)，即组合数：  
C(m-1,m+n-2) = A(m-1,m+n-2) / A(m-1,m-1) = (m+n−2)(m+n−3)⋯n / (m-1)! = (m+n−2)(m+n−3)⋯n / (m-1)(m-2)...1（分子乘到n是由于m+n−2 - (m-1) + 1）  
计算上述公式的遍历次数为 m-1 次，为使得遍历次数最小，选取较小的行数（颠倒行列数不影响最后的结果）。与此同时，为使得结果的计算过程中不超过long类型的范围，在每次循环体中都要**“乘以一尽量小的分子（从i=n开始往大递增乘）和除以一尽量小的分母（从fac=1往大递增除）”**。

题解：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if (m > n) return uniquePaths(n, m);
        long result = 1; // 结果的计算过程中可能超出int类型的范围
        for (int i = n, fac = 1; i <= m + n - 2; i++, fac++) { // 遍历 m-1 次
            result = result * i / fac;
        }
        return (int) result;
    }
}
```

tips：

- 选取最少遍历次数 m-1 / n-1 采用递归的方式（最多只自己调用自己一次）;
- 时间复杂度：O(min(m, n))；
- 空间复杂度：O(1)